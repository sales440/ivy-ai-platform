import { invokeLLM } from "../_core/llm";
import { getDb } from "../db";
import { companies, fagorContacts, fagorCampaignEnrollments } from "../../drizzle/schema";
import { eq } from "drizzle-orm";

/**
 * Ivy-Orchestrator: Conversational AI Agent
 * 
 * This agent allows natural language interaction for:
 * - Creating new companies
 * - Creating email campaigns
 * - Managing contacts
 * - Monitoring campaign metrics
 * - Orchestrating multi-step workflows
 */

export interface ChatMessage {
  role: "system" | "user" | "assistant";
  content: string;
}

export interface ConversationContext {
  userId: number;
  companyId?: number;
  conversationHistory: ChatMessage[];
  currentIntent?: string;
  extractedEntities?: Record<string, any>;
}

/**
 * Main function to process natural language commands
 */
export async function processConversationalCommand(
  userMessage: string,
  context: ConversationContext
): Promise<{ response: string; action?: any; updatedContext: ConversationContext }> {
  
  // Add user message to conversation history
  context.conversationHistory.push({
    role: "user",
    content: userMessage,
  });

  // Build system prompt
  const systemPrompt = buildSystemPrompt(context);

  // Call LLM to understand intent and generate response
  const llmResponse = await invokeLLM({
    messages: [
      { role: "system", content: systemPrompt },
      ...context.conversationHistory,
    ],
    response_format: {
      type: "json_schema",
      json_schema: {
        name: "orchestrator_response",
        strict: true,
        schema: {
          type: "object",
          properties: {
            intent: {
              type: "string",
              description: "The detected intent: create_company, create_campaign, add_contacts, get_metrics, general_question, or confirmation_needed",
            },
            response: {
              type: "string",
              description: "The AI assistant's response to the user",
            },
            action: {
              type: "object",
              description: "The action to execute (if any)",
              properties: {
                type: {
                  type: "string",
                  description: "Action type: create_company, create_campaign, add_contacts, enroll_contacts, get_metrics",
                },
                parameters: {
                  type: "object",
                  description: "Parameters for the action",
                },
              },
              required: ["type", "parameters"],
            },
            extractedEntities: {
              type: "object",
              description: "Entities extracted from user message",
            },
            needsConfirmation: {
              type: "boolean",
              description: "Whether the action needs user confirmation before execution",
            },
          },
          required: ["intent", "response"],
          additionalProperties: false,
        },
      },
    },
  });

  const parsedResponse = JSON.parse(llmResponse.choices[0]?.message?.content || "{}");

  // Update context
  context.currentIntent = parsedResponse.intent;
  context.extractedEntities = parsedResponse.extractedEntities || {};
  context.conversationHistory.push({
    role: "assistant",
    content: parsedResponse.response,
  });

  // Execute action if provided and doesn't need confirmation
  let actionResult;
  if (parsedResponse.action && !parsedResponse.needsConfirmation) {
    actionResult = await executeAction(parsedResponse.action, context);
  }

  return {
    response: parsedResponse.response,
    action: actionResult,
    updatedContext: context,
  };
}

/**
 * Build system prompt for the AI orchestrator
 */
function buildSystemPrompt(context: ConversationContext): string {
  return `You are Ivy-Orchestrator, an AI assistant integrated into the Ivy.AI platform dashboard.

Your role is to help users manage their sales automation campaigns through natural language conversation.

You can help with:
1. **Creating new companies** - When a new client purchases Ivy.AI's sales force
2. **Creating email campaigns** - Multi-step drip campaigns with automated follow-ups
3. **Managing contacts** - Importing and organizing prospect lists
4. **Monitoring metrics** - Campaign performance, open rates, conversions
5. **Orchestrating workflows** - Complex multi-agent automation sequences

Current context:
- User ID: ${context.userId}
- Company ID: ${context.companyId || "Not set"}
- Current Intent: ${context.currentIntent || "Unknown"}

When the user wants to create a campaign, ask for:
1. Company name (if not already set)
2. Campaign name and description
3. Target audience details
4. Number of email steps (typically 3-5)
5. Delay between steps (in days)
6. Email content preferences (tone, style, key messages)

When the user provides contact information, extract:
- Names
- Email addresses
- Company names
- Roles/titles
- Any other relevant data

Always:
- Be conversational and helpful
- Ask clarifying questions when needed
- Confirm before executing critical actions (creating campaigns, sending emails)
- Provide clear summaries of what you've done
- Use markdown formatting for better readability

Format your responses as JSON with:
{
  "intent": "create_company | create_campaign | add_contacts | get_metrics | general_question | confirmation_needed",
  "response": "Your conversational response to the user",
  "action": {
    "type": "create_company | create_campaign | add_contacts | enroll_contacts | get_metrics",
    "parameters": { ... }
  },
  "extractedEntities": { ... },
  "needsConfirmation": true/false
}`;
}

/**
 * Execute an action based on AI's decision
 */
async function executeAction(
  action: { type: string; parameters: any },
  context: ConversationContext
): Promise<any> {
  const db = await getDb();
  if (!db) {
    throw new Error("Database not available");
  }

  switch (action.type) {
    case "create_company":
      return await createCompany(action.parameters, db);
    
    case "create_campaign":
      return await createCampaign(action.parameters, context, db);
    
    case "add_contacts":
      return await addContacts(action.parameters, context, db);
    
    case "enroll_contacts":
      return await enrollContacts(action.parameters, context, db);
    
    case "get_metrics":
      return await getMetrics(action.parameters, context, db);
    
    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

/**
 * Create a new company
 */
async function createCompany(params: any, db: any) {
  const [result] = await db.insert(companies).values({
    name: params.name,
    slug: params.name.toLowerCase().replace(/\s+/g, "-"),
    industry: params.industry || null,
    plan: params.plan || "starter",
    website: params.website || null,
    contactEmail: params.contactEmail || null,
    contactPhone: params.contactPhone || null,
    isActive: true,
  });

  return {
    success: true,
    companyId: result.insertId,
    message: `Company "${params.name}" created successfully with ID ${result.insertId}`,
  };
}

/**
 * Create a new email campaign
 */
async function createCampaign(params: any, context: ConversationContext, db: any) {
  if (!context.companyId) {
    throw new Error("Company ID is required to create a campaign");
  }

  // Generate campaign ID
  const campaignId = `campaign-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

  // Create campaign
  const [campaignResult] = await db.insert(campaigns).values({
    companyId: context.companyId,
    campaignId,
    name: params.name,
    description: params.description || null,
    type: "email",
    status: "draft",
    targetAudience: params.targetAudience || null,
    startDate: params.startDate ? new Date(params.startDate) : null,
    endDate: params.endDate ? new Date(params.endDate) : null,
    timezone: params.timezone || "America/Chicago",
    createdBy: context.userId,
  });

  const dbCampaignId = campaignResult.insertId;

  // Generate email content for each step using LLM
  const steps = params.steps || 3;
  for (let i = 1; i <= steps; i++) {
    const emailContent = await generateEmailContent(i, steps, params, context);
    
    await db.insert(campaignSteps).values({
      campaignId: dbCampaignId,
      stepNumber: i,
      name: emailContent.name,
      description: emailContent.description,
      delayDays: i === 1 ? 0 : params.delayDays || 3,
      delayHours: 0,
      channelType: "email",
      actionType: "send_email",
      actionConfig: JSON.stringify({
        emailSubject: emailContent.subject,
        emailBody: emailContent.body,
        variables: {
          name: "{{name}}",
          company: "{{company}}",
          role: "{{role}}",
        },
      }),
    });
  }

  return {
    success: true,
    campaignId: dbCampaignId,
    campaignUUID: campaignId,
    message: `Campaign "${params.name}" created successfully with ${steps} email steps`,
    steps,
  };
}

/**
 * Generate email content using LLM
 */
async function generateEmailContent(
  stepNumber: number,
  totalSteps: number,
  campaignParams: any,
  context: ConversationContext
) {
  const prompt = `Generate email content for step ${stepNumber} of ${totalSteps} in a B2B sales campaign.

Campaign details:
- Name: ${campaignParams.name}
- Description: ${campaignParams.description || "Not provided"}
- Target audience: ${JSON.stringify(campaignParams.targetAudience || {})}
- Tone: ${campaignParams.tone || "professional and friendly"}
- Key messages: ${campaignParams.keyMessages || "Not provided"}

Email ${stepNumber} should:
${stepNumber === 1 ? "- Introduce the problem/pain point\n- Establish credibility\n- Provide initial value" : ""}
${stepNumber === 2 ? "- Present the solution\n- Highlight benefits\n- Include social proof or case study" : ""}
${stepNumber === totalSteps ? "- Create urgency\n- Clear call-to-action\n- Make it easy to respond" : ""}
${stepNumber > 2 && stepNumber < totalSteps ? "- Build on previous emails\n- Address common objections\n- Provide additional value" : ""}

Generate:
1. Email subject line (under 60 characters)
2. Email body (HTML format, 200-300 words)
3. Step name (e.g., "Email 1: The Problem")
4. Step description (one sentence)

Use these variables in the email body:
- {{name}} - Recipient's name
- {{company}} - Recipient's company
- {{role}} - Recipient's role/title

Format the email body as professional HTML with proper styling.`;

  const response = await invokeLLM({
    messages: [
      {
        role: "system",
        content: "You are an expert B2B sales copywriter. Generate compelling email content that drives engagement and conversions.",
      },
      {
        role: "user",
        content: prompt,
      },
    ],
    response_format: {
      type: "json_schema",
      json_schema: {
        name: "email_content",
        strict: true,
        schema: {
          type: "object",
          properties: {
            name: { type: "string" },
            description: { type: "string" },
            subject: { type: "string" },
            body: { type: "string" },
          },
          required: ["name", "description", "subject", "body"],
          additionalProperties: false,
        },
      },
    },
  });

  return JSON.parse(response.choices[0]?.message?.content || "{}");
}

/**
 * Add contacts to a company
 */
async function addContacts(params: any, context: ConversationContext, db: any) {
  if (!context.companyId) {
    throw new Error("Company ID is required to add contacts");
  }

  const contacts = params.contacts || [];
  const results = {
    imported: 0,
    skipped: 0,
    errors: [] as string[],
  };

  for (const contact of contacts) {
    try {
      const contactId = `contact-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      await db.insert(campaignContacts).values({
        companyId: context.companyId,
        contactId,
        name: contact.name,
        email: contact.email,
        company: contact.company || null,
        role: contact.role || null,
        phone: contact.phone || null,
        linkedInUrl: contact.linkedInUrl || null,
        industry: contact.industry || null,
        companySize: contact.companySize || null,
        location: contact.location || null,
        source: "ai_chat_import",
        tags: contact.tags || null,
        status: "active",
      });
      
      results.imported++;
    } catch (error: any) {
      if (error.code === "ER_DUP_ENTRY") {
        results.skipped++;
      } else {
        results.errors.push(`${contact.email}: ${error.message}`);
      }
    }
  }

  return {
    success: true,
    ...results,
    message: `Imported ${results.imported} contacts, skipped ${results.skipped} duplicates`,
  };
}

/**
 * Enroll contacts in a campaign
 */
async function enrollContacts(params: any, context: ConversationContext, db: any) {
  const campaignId = params.campaignId;
  const contactIds = params.contactIds || [];

  // Get campaign steps count
  const steps = await db
    .select()
    .from(campaignSteps)
    .where(eq(campaignSteps.campaignId, campaignId));

  const totalSteps = steps.length;

  const results = {
    enrolled: 0,
    skipped: 0,
  };

  for (const contactId of contactIds) {
    try {
      const enrollmentId = `enrollment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      await db.insert(campaignEnrollments).values({
        enrollmentId,
        campaignId,
        contactId,
        currentStep: 0,
        totalSteps,
        status: "pending",
        nextStepAt: new Date(), // Execute first step immediately
      });
      
      results.enrolled++;
    } catch (error) {
      results.skipped++;
    }
  }

  return {
    success: true,
    ...results,
    message: `Enrolled ${results.enrolled} contacts in campaign`,
  };
}

/**
 * Get campaign metrics
 */
async function getMetrics(params: any, context: ConversationContext, db: any) {
  const campaignId = params.campaignId;

  // Get campaign info
  const [campaign] = await db
    .select()
    .from(campaigns)
    .where(eq(campaigns.id, campaignId))
    .limit(1);

  if (!campaign) {
    throw new Error("Campaign not found");
  }

  // Get enrollment stats
  const enrollments = await db
    .select()
    .from(campaignEnrollments)
    .where(eq(campaignEnrollments.campaignId, campaignId));

  const stats = {
    totalEnrolled: enrollments.length,
    active: enrollments.filter((e) => e.status === "active").length,
    completed: enrollments.filter((e) => e.status === "completed").length,
    failed: enrollments.filter((e) => e.status === "failed").length,
    totalEmailsSent: enrollments.reduce((sum, e) => sum + (e.emailsSent || 0), 0),
    totalEmailsOpened: enrollments.reduce((sum, e) => sum + (e.emailsOpened || 0), 0),
    totalEmailsClicked: enrollments.reduce((sum, e) => sum + (e.emailsClicked || 0), 0),
    totalResponses: enrollments.filter((e) => e.responded).length,
    totalConversions: enrollments.filter((e) => e.converted).length,
  };

  // Calculate rates
  const openRate = stats.totalEmailsSent > 0 
    ? ((stats.totalEmailsOpened / stats.totalEmailsSent) * 100).toFixed(2)
    : "0.00";
  const clickRate = stats.totalEmailsSent > 0
    ? ((stats.totalEmailsClicked / stats.totalEmailsSent) * 100).toFixed(2)
    : "0.00";
  const responseRate = stats.totalEnrolled > 0
    ? ((stats.totalResponses / stats.totalEnrolled) * 100).toFixed(2)
    : "0.00";
  const conversionRate = stats.totalEnrolled > 0
    ? ((stats.totalConversions / stats.totalEnrolled) * 100).toFixed(2)
    : "0.00";

  return {
    success: true,
    campaign: {
      id: campaign.id,
      name: campaign.name,
      status: campaign.status,
    },
    stats,
    rates: {
      openRate: `${openRate}%`,
      clickRate: `${clickRate}%`,
      responseRate: `${responseRate}%`,
      conversionRate: `${conversionRate}%`,
    },
  };
}

/**
 * Helper function to extract contacts from natural language text
 */
export async function extractContactsFromText(text: string): Promise<any[]> {
  const prompt = `Extract contact information from the following text. Return a JSON array of contacts.

Text:
${text}

Extract:
- name (required)
- email (required)
- company (optional)
- role (optional)
- phone (optional)

If the text contains a list, table, or structured data, parse it accordingly.
If the text is unstructured, extract whatever information is available.

Return an empty array if no valid contacts are found.`;

  const response = await invokeLLM({
    messages: [
      {
        role: "system",
        content: "You are a data extraction specialist. Extract structured contact information from unstructured text.",
      },
      {
        role: "user",
        content: prompt,
      },
    ],
    response_format: {
      type: "json_schema",
      json_schema: {
        name: "contacts_extraction",
        strict: true,
        schema: {
          type: "object",
          properties: {
            contacts: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: { type: "string" },
                  email: { type: "string" },
                  company: { type: "string" },
                  role: { type: "string" },
                  phone: { type: "string" },
                },
                required: ["name", "email"],
                additionalProperties: false,
              },
            },
          },
          required: ["contacts"],
          additionalProperties: false,
        },
      },
    },
  });

  const parsed = JSON.parse(response.choices[0]?.message?.content || "{}");
  return parsed.contacts || [];
}
